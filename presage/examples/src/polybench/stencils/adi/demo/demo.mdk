Title         : `PRESAGE`
Author        : **`PR`**ot**`E`**cting **`S`**tructured **`A`**ddress **`G`**eneration against Soft **`E`**rrors
Author        : `Visualization using Polybench/C :` **`A`**lternate **`D`**irection **`I`**mplicit `Kernel`
Bibliography: presage.bib

<style>
    body.madoko {
      max-width: 75pc; 
    }   
</style>


[TITLE]

# `Alternating Direction Implicit Kernel`

In numerical analysis, the *Alternating Direction Implicit* (ADI) method is a *finite difference method* 
for solving *partial differential equations* (PDEs) [@adi] .It is mostly used for solving the problem of **heat conduction** or solving the **diffusion equation** in two or more dimensions. 
A sample implementation of the main `ADI` kernel is provided here for ease of reference [@poly]

```javascript
 for (t=1; t<=tsteps; t++) {
    //Column Sweep
    for (i=1; i<n-1; i++) {
      v[i] = 1.0;
      p[i*n] = 0.0;
      q[i*n] = v[i];
      for (j=1; j<n-1; j++) {
        p[i*n+j] = -c / (a*p[i*n+(j-1)]+b);
        q[i*n+j] = ( -d*u[j*n+(i-1)]+(1.0+2.0*d)*u[j*n+i] - 
                     f*u[j*n+(i+1)]
                     -a*q[i*n+(j-1)])/(a*p[i*n+(j-1)]+b );
      }
      
      v[n*(n-1)+i] = 1.0;
      for (j=n-2; j>=1; j--) {
        v[j*n+i] = p[i*n+j] * v[(j+1)*n+i] + q[i*n+j];
      }
    }

    //Row Sweep
    for (i=1; i<n-1; i++) {
      u[i*n] = 1.0;
      p[i*n] = 0.0;
      q[i*n] = u[i*n];
      for (j=1; j<n-1; j++) {
        p[i*n+j] = -f / (d*p[i*n+(j-1)]+e);
        q[i*n+j] = ( -a*v[(i-1)*n+j]+(1.0+2.0*a)*v[i*n+j] 
                     -c*v[(i+1)*n+j]
                     -d*q[i*n+(j-1)])/(d*p[i*n+(j-1)]+e );
      }
      u[i*n+(n-1)] = 1.0;

      for (j=n-2; j>=1; j--) {
            u[i*n+j] = p[i*n+j] * u[i*n+(j+1)] + q[i*n+j];
      }
    }    
```

## `Initial Conditions`

The adi kernel shown above is timesteped simulation and its initialized using:

```javascript
/* Array initialization. */
void init_array (int n,double *u)
{
  int i, j;
  srand(0);
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++)
      {
    	u[i*n+j] =  (double) rand(); 
      }
}
```
## `Boundary Conditions`

The kernel as shown in [#sec-alternating-direction-implicit-kernel] maintains the boundary condition of `u,q,p and v` internally.

## `Output`

This kernel generates `four` 2D arrays, `u,q,p and v` for each timestep and in the plots below, we visualize these arryas for: 
```javascript
TimeSteps: 50
Dimentions: (X=25,Y=25)
```

# `PRESAGE` [@psg]

`PRESAGE` is an open-source [tool](https://utahfmr.github.io/PRESAGE/) which is aimed at protecting structured address computations against soft errors. It is developed using LLVM compiler infrastructure. PRESAGE applies a novel rewriting scheme, dubbed Relative Base Addressing (RBA) scheme, which introduces dependency chains between same-base-address-sharing GetElementPtr instructions at LLVM intermediate representation (IR) level. Currently, `PRESAGE` is extensively tested on C benchmarks drawn from Polybench/C benchmark suite. However, it should work for any high-level language which can be compiled to LLVM IR.



We now provide visualizations obtained for ADI kernels with and without
presage transformaed applied. We also study the error propagation 
characteristics of ADI kernel on native and presage transformed version

# `Visualisations`

## `Simulations of the native version of ADI Kernel`

**u** ![native_u] **q** ![native_q]  
**p** ![native_p] **v** ![native_v] 

## `Simulations with Fault Injection`

Among the `four` output arrays `[u,q,p,v]`, we randomly choose an array `[q]` to perform `fault injection`.
For the sake of visualization, we perform deterministic *fault injection* at a `Fixed-Timestep:25` and at the center of the `2D array`. Here *fault injection* refers to a single bit-flip in the address of `q[i/2,j/2]` at `Timesteps/2`

The difference between the output array `q` generated by the native kernel and fault-injected kernel is plotted as **DNF** below on the left.

## `Simulation of the Presage transformed Binary with Fault Injection`

The kernel shown above is setup for transformation using [@psg] and the difference between the native output q and the array generated by this transformation is plotted in right, below as **DNP** 

**DNF**: **D**ifference between **N**ative and **F**ault Injection on Native Binary  
**DNP**:  **D**ifference between **N**ative and Fault Injection on **P**resage transformed Binary  

Notice the `Value` axis of **DNP** , the single event upset to the `&q[i/2,j/2]` causes the data corruption to be evident by diverging to the range `10e6` 

**DNF** ![dnf] **DNP** ![dnp]  

[BIB]

[native_u]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/native_u.gif "native_u" { width:auto; max-width:39%; vertical-align:middle }

[native_q]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/native_q.gif "native_q" { width:auto; max-width:39%; vertical-align:middle }

[native_p]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/native_p.gif "native" { width:auto; max-width:39%; vertical-align:middle }

[native_v]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/native_v.gif "native_v" { width:auto; max-width:39%; vertical-align:middle }

[dnf]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/dnf.gif "dnf" {width:auto; max-width:39%; vertical-align:middle; caption:"test"; }

[dnp]: http://www.cs.utah.edu/~vinu/research/stencils/presage/presage_results/vizs/barc/dnp.gif "dnp" {width:auto; max-width:39%; vertical-align:middle}

